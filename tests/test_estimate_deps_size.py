# -*- coding: utf-8 -*-
import pytest
from unittest.mock import patch, MagicMock
import sys
import os
from pathlib import Path
import httpx

# 將專案根目錄添加到 sys.path 中，以便導入 scripts 中的模組
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from scripts import estimate_deps_size

@patch('scripts.estimate_deps_size.subprocess.run')
def test_get_resolved_dependencies_success(mock_subprocess_run):
    """
    測試 get_resolved_dependencies 函式在成功執行 pip-compile 後能否正確解析輸出。
    """
    # 步驟 1: 準備模擬

    # 模擬 pip-compile 成功執行
    mock_subprocess_run.return_value = MagicMock(returncode=0)

    # 模擬 output_file.read_text() 的返回內容
    mock_requirements_content = """
#
# This file is autogenerated by pip-compile
#
--index-url https://pypi.org/simple

# via -r apps/main_dashboard/requirements.in
fastapi==1.0.0
uvicorn==2.0.0 # via fastapi
click==8.2.1
    """

    # 我們需要模擬 Path 物件和它的方法
    with patch('pathlib.Path.exists') as mock_path_exists, \
         patch('pathlib.Path.read_text') as mock_read_text, \
         patch('pathlib.Path.unlink'): # 我們也需要模擬 unlink 以免出錯

        mock_path_exists.return_value = True
        mock_read_text.return_value = mock_requirements_content

        # 步驟 2: 執行被測試的函式
        # 我們傳入一個假的 Path 物件，因為它的行為已經被 mock 了
        fake_req_in_path = Path("dummy/path/requirements.in")
        dependencies = estimate_deps_size.get_resolved_dependencies(fake_req_in_path)

        # 步驟 3: 斷言結果
        expected_dependencies = ["fastapi==1.0.0", "uvicorn==2.0.0", "click==8.2.1"]
        assert dependencies == expected_dependencies, f"Expected {expected_dependencies}, but got {dependencies}"

        # 驗證 subprocess.run 被以預期的方式呼叫
        mock_subprocess_run.assert_called_once()
        # 檢查呼叫參數中是否包含我們傳入的假路徑
        call_args = mock_subprocess_run.call_args[0][0]
        assert str(fake_req_in_path) in call_args

# --- 測試 get_wheel_size ---

MOCK_METADATA = {
    "releases": {
        "1.0.0": [
            {"filename": "package-1.0.0-py3-none-any.whl", "packagetype": "bdist_wheel", "size": 1000},
            {"filename": "package-1.0.0.tar.gz", "packagetype": "sdist", "size": 900}
        ],
        "2.0.0": [
            {"filename": "package-2.0.0-cp39-cp39-manylinux_2_17_x86_64.whl", "packagetype": "bdist_wheel", "size": 2000},
            {"filename": "package-2.0.0.tar.gz", "packagetype": "sdist", "size": 1800}
        ],
        "3.0.0": [
             {"filename": "package-3.0.0.tar.gz", "packagetype": "sdist", "size": 2500}
        ]
    }
}

@pytest.mark.parametrize("version, expected_size", [
    ("1.0.0", 1000), # 應選擇 py3-none-any wheel
    ("2.0.0", 2000), # 應選擇唯一的 wheel
    ("3.0.0", 0),    # 沒有 wheel，應返回 0
    ("4.0.0", 0),    # 版本不存在，應返回 0
])
def test_get_wheel_size(version, expected_size):
    """
    測試 get_wheel_size 函式能否根據不同情況返回正確的檔案大小。
    """
    size = estimate_deps_size.get_wheel_size(MOCK_METADATA, version)
    assert size == expected_size

def test_get_wheel_size_with_empty_data():
    """
    測試當傳入空的元數據或版本時，get_wheel_size 的行為。
    """
    assert estimate_deps_size.get_wheel_size({}, "1.0.0") == 0
    assert estimate_deps_size.get_wheel_size(MOCK_METADATA, None) == 0
    assert estimate_deps_size.get_wheel_size(None, "1.0.0") == 0

# --- 測試 get_package_metadata ---

import asyncio
from unittest.mock import AsyncMock

@pytest.mark.anyio
async def test_get_package_metadata_success():
    """
    測試 get_package_metadata 函式在成功獲取 API 資料時的行為。
    """
    mock_client = AsyncMock(spec=httpx.AsyncClient)
    mock_response = MagicMock()
    mock_response.status_code = 200
    mock_response.json.return_value = {"info": {"name": "fastapi"}}
    # 直接設定協程的返回結果
    mock_client.get.return_value = mock_response

    spec, metadata = await estimate_deps_size.get_package_metadata("fastapi==1.0.0", mock_client)

    assert spec == "fastapi==1.0.0"
    assert metadata["info"]["name"] == "fastapi"
    mock_client.get.assert_called_once_with("https://pypi.org/pypi/fastapi/json")

@pytest.mark.anyio
async def test_get_package_metadata_not_found():
    """
    測試當 API 返回 404 Not Found 時，get_package_metadata 的行為。
    """
    mock_client = MagicMock(spec=httpx.AsyncClient)
    # 模擬 httpx 的異常引發行為
    mock_client.get.side_effect = httpx.HTTPStatusError(
        "Not Found", request=MagicMock(), response=MagicMock(status_code=404)
    )

    spec, metadata = await estimate_deps_size.get_package_metadata("nonexistent-package==1.0", mock_client)

    assert spec == "nonexistent-package==1.0"
    assert metadata is None
