# 鳳凰之心 v16.0：權威性架構藍圖

這份文件是一份權威性的技術藍圖，旨在精準反映專案 v16.0 的最終形態。它不僅描繪了檔案結構和自動化流程，更深入闡述了其背後應對現代化開發挑戰的設計哲學。

---

## 一、 設計哲學：應對 CI/CD 的三重困境

我們的架構是為了解決在現代持續整合與部署 (CI/CD) 環境中普遍存在的三大核心瓶頸而設計的：

1.  **空間瓶頸 (硬碟空間耗盡)**: 在資源受限的容器化環境中，傳統「一次性安裝所有依賴」的流程極易導致硬碟空間不足而失敗。
2.  **時間瓶頸 (CPU 資源浪費)**: 單線程的循序測試無法充分利用多核心 CPU，導致測試時間過長，嚴重拖慢開發迭代速度。
3.  **穩定性瓶頸 (流程意外掛起)**: 單一測試案例的意外卡死（如 API 等待、死循環）會導致整個 CI/CD 流程被無限期阻塞，無法自動報告錯誤。

為此，我們確立了三大核心解決策略，它們共同構建了一個快速、穩健且高效的系統：

-   **策略一：原子化隔離與即時清理 (解決空間瓶頸)**
    我們將每個測試任務視為一個「原子」單元。測試前，僅為其建立一個包含最小依賴集的專用虛擬環境；測試結束後，立即徹底刪除該環境，將硬碟空間 100% 釋放。這確保了資源峰值佔用永遠在可控範圍內。

-   **策略二：輕量級多核心平行處理 (解決時間瓶頸)**
    我們透過 `multiprocessing` 實現應用級平行 (同時測試多個 App)，並利用 `pytest-xdist` 在每個 App 內部實現測試級平行。這套輕量級方案能在不增加空間負擔的前提下，壓榨 CPU 性能，大幅縮短測試總耗時。

-   **策略三：主動式超時強制中斷 (解決穩定性瓶頸)**
    我們為每一個測試案例都設定了一個「生命時鐘」（透過 `pytest-timeout`）。任何超時的測試都會被自動中斷並標記為失敗，確保 CI/CD 流程永遠不會被單一故障點所阻塞。

---

## 二、 v16.0 終極檔案結構與核心工具鏈

這是專案的最終檔案結構，精準反映了所有關鍵組件及其職責。

```
/PHOENIX_HEART_PROJECT/
│
├── 🚀 launch.py                   # 主啟動腳本 (TUI 介面，伺服器適用)。
├── 🚀 phoenix_starter.py          # (可選) 視覺化啟動器，功能與 launch.py 類似。
├── 🧪 smart_e2e_test.py            # 新一代 Python 智能測試腳本 (平行、穩定)。
├── 📄 generate_report.py          # 【新】獨立的報告生成插件。
│
├── 📦 apps/                        # 所有獨立微服務的家。
├── 🛠️ core_utils/                 # 核心工具模組 (安全安裝、資源監控等)。
├── ⚙️ config/                     # 全域設定中心。
├── 📝 logs/                        # 日誌與報告的輸出目錄。
├── 🧪 tests/                       # 品質保證中心。
├── 🏃 run/                         # Colab 等特定環境的執行器。
├── 📚 docs/                         # 專案文件 (架構圖、指南等)。
├──  temp/                         # 【新】暫存檔案、測試產物與上傳的歸檔目錄。
│
└── 📄 .gitignore
```

### **核心工具鏈詳解:**

*   **`launch.py` / `phoenix_starter.py`**: 專案的兩大入口。`launch.py` 是核心，提供 TUI 介面並負責所有後端邏輯。`phoenix_starter.py` 提供一個類似但可選的啟動方式。
*   **`smart_e2e_test.py`**: 新一代的 Python 測試指揮官。它取代了傳統的 shell 腳本，透過 `multiprocessing` 和 `pytest-xdist` 實現了前所未有的平行化測試能力，並整合 `pytest-timeout` 確保流程穩定性。
*   **`generate_report.py`**: 一個獨立的報告生成「插件」。它由 `launch.py` 在任務結束時呼叫，負責從 SQLite 資料庫中讀取數據並產生多維度的 Markdown 分析報告，實現了報告與主邏輯的解耦。
*   **`run/colab_runner.py`**: 專為 Google Colab 設計的 HTML 儀表板啟動器。它透過讀寫分離的資料庫驅動架構，確保了前端顯示和後端服務的穩定運行。
*   **`core_utils/`**: 專案的「引擎室」。`safe_installer.py` 負責執行原子化的安全安裝，而 `resource_monitor.py` 則在每一步安裝前進行資源健康檢查，是實現「空間瓶頸」解決方案的關鍵。
*   **`docs/TEST.md`**: 與本架構文件相輔相成的測試策略藍圖，詳細說明了如何使用 `smart_e2e_test.py` 以及其背後的測試模式。
*   **`requirements-dev.txt`**: 一個鎖定版本的依賴檔案，專門用於設定開發與測試環境。它確保了所有開發者和 CI/CD 流程都使用完全相同的套件版本來執行測試，從而消除了「在我機器上可以跑」的常見問題。

---

## 三、 Colab 啟動器與 API 最終架構：資料庫驅動方案

在經歷了數次迭代後，我們最終確定了一套以穩定性為最高原則的架構，旨在徹底解決先前 GoTTY 等方案的複雜性與不確定性。

### 核心概念：讀寫分離與單一真相來源

我們將**「做事」與「顯示」**完全分離。
1.  **寫入方 (`launch.py`)**: 作為後端主力部隊，`launch.py` 專心執行所有任務（安裝、啟動 App 等），並將所有狀態與日誌**持續寫入**唯一的真相來源：一個獨立的 **SQLite 資料庫 (`state.db`)**。
2.  **讀取方 (`run/colab_runner.py` 或其他 API 客戶端)**: 前端顯示器（例如 Colab Cell）或任何需要監控狀態的工具，則專心**讀取**數據。`launch.py` 在啟動時，會一併啟動一個輕量級的 **aiohttp API 伺服器**。這個 API 伺服器的唯一職責就是從 SQLite 資料庫讀取最新狀態，並以 JSON 格式提供給前端。

兩者透過資料庫和一個只讀的 API 進行溝通，互不干擾，確保了後端任務的穩定執行不會被前端的任何問題所影響。

### 架構草圖

```mermaid
graph TD
    subgraph "後端核心"
        D[🚀 launch.py<br>(背景主力部隊)] -- 寫入 --> C[(state.db)];
        E[🌐 aiohttp API<br>(由 launch.py 啟動)] -- 讀取 --> C;
    end

    subgraph "前端顯示"
        A[👨‍💻 使用者] --> B{Colab Cell};
        B -- 每秒 API 請求 --> E;
    end

    subgraph "離線分析"
        F[📄 generate_report.py] -- 讀取 --> C;
    end

    style C fill:#f9f,stroke:#333,stroke-width:2px
```

### 核心優勢

*   **極致穩定**：前端顯示的崩潰，完全不影響後端核心任務的執行。真相永遠保存在資料庫中。
*   **架構簡潔**：沒有任何額外的網路服務 (GoTTY, WebSocket)，只有 Python、aiohttp 和 SQLite，除錯和維護成本降至最低。
*   **數據完整與可重用**：所有事件和狀態都被完整記錄。任務結束後，獨立的 `generate_report.py` 可以隨時從資料庫中重新產生完整的執行報告，用於分析或歸檔。

---

## 四、架構演進歷程：從問題到解決方案

一個健壯的架構不是一蹴可幾的，而是不斷解決問題、持續演進的結果。本節記錄了專案在發展過程中遇到的關鍵挑戰以及對應的解決方案，這些經驗是專案寶貴的無形資產。

### 1. 問題：CI/CD 環境下的不穩定性
- **遇到的狀況**: 在早期的版本中，我們嘗試使用 `GoTTY` 或直接將 `launch.py` 的 TUI 輸出串流到前端。這種方法非常脆弱，任何 TUI 渲染的微小錯誤、甚至是網路延遲，都會導致整個流程崩潰或卡死。
- **失敗的嘗試**: 繼續優化 TUI 輸出，試圖用更複雜的控制字元來解決問題。這讓程式碼變得愈加複雜且難以維護，治標不治本。
- **成功的解決方案 (v12)**: **引入資料庫驅動架構**。我們意識到問題的根源在於「執行」和「顯示」的耦合。透過讓 `launch.py` 只專注於將狀態寫入 SQLite，並讓前端只專注於從 API 讀取數據，我們徹底切斷了兩者之間的直接聯繫，實現了極高的穩定性。

### 2. 問題：開發環境不一致與依賴地獄
- **遇到的狀況**: 開發者 A 在本地安裝了 `pandas v2.0`，測試通過；而開發者 B 安裝了 `pandas v2.1`，部分 API 行為發生變化導致測試失敗。這種「在我機器上可以跑」的問題嚴重影響了團隊協作效率。
- **失敗的嘗試**: 口頭約定大家使用相同的版本，或手動維護一個包含所有間接依賴的 `requirements.txt`。前者不可靠，後者極其繁瑣且容易出錯。
- **成功的解決方案 (v12+)**: **引入 `pip-tools` 進行依賴鎖定**。我們讓開發者只在 `requirements.in` 中聲明直接依賴，然後使用 `pip-compile` 命令自動生成包含所有層級依賴且版本被完全鎖定的 `requirements.txt`。這保證了任何環境下安裝的依賴都是完全一致的，根治了此問題。

### 3. 問題：報告系統與主邏輯耦合
- **遇到的狀況**: 最初，報告產生的邏輯是 `launch.py` 的一部分。這導致了幾個問題：
    1.  要測試報告功能，必須完整運行一次 `launch.py`，非常耗時。
    2.  報告邏輯的任何改動，都有可能意外影響到主程序的穩定性。
    3.  如果任務中途失敗，儲存下來的資料庫就無法被用來重新產生報告。
- **失敗的嘗試**: 在 `ReportGenerator` 類別中增加更多的錯誤處理，試圖隔離其影響。但這無法解決根本的耦合問題。
- **成功的解決方案 (v16)**: **報告系統插件化**。我們將報告邏輯完全移出，製作成一個獨立的 `generate_report.py` 命令列工具。`launch.py` 在結束時只負責呼叫這個腳本。這使得報告系統可以被獨立測試、獨立擴展，並且可以對任何符合格式的資料庫檔案執行，極大地增強了靈活性和可維護性。

---

## 五、V4 核心架構：預設快速驗證與參數化完整執行

V4 架構在 V3 的基礎上進行了關鍵的易用性改進，將**快速驗證模式設為預設行為**，同時保留了執行完整任務的能力。這使得開發者可以近乎即時地檢查 TUI 和核心日誌功能，極大地提升了日常開發和偵錯的效率。

### 核心變更：

*   **預設快速模式**：直接執行 `python launch.py` 將**不再**安裝任何大型依賴或啟動後端 App。它會立即啟動 TUI，模擬一個簡短的執行流程，並在幾秒鐘內完成。這成為了驗證系統核心顯示和日誌功能的標準方法。
*   **參數化完整模式**：過去的完整執行流程現在需要透過一個明確的命令列旗標來啟動：`python launch.py --full`。只有在指定此旗標時，系統才會執行完整的依賴安裝和後端服務啟動。
*   **內建依賴引導**：`launch.py` 現在能夠自我檢測並自動安裝其運行所需的核心 Python 套件（如 `pytz`, `psutil`, `ipython`, `nest_asyncio`），免除了使用者的手動設定步驟。

### 新的標準執行流程

1.  **日常開發與驗證 (預設)**:
    ```bash
    python launch.py
    ```
    *   **目的**：快速檢查 TUI 是否正常渲染，日誌是否可以生成。
    *   **耗時**：< 5 秒。

2.  **完整部署與測試 (手動觸發)**:
    ```bash
    python launch.py --full
    ```
    *   **目的**：執行完整的端到端流程，包括安裝所有應用的依賴、啟動後端服務。
    *   **耗時**：數分鐘（取決於網路速度和依賴大小）。

這個改進使得 `launch.py` 同時滿足了**快速迭代**和**完整執行**兩種核心需求，並透過將簡單性設為預設值，提供了更流暢的開發者體驗。
