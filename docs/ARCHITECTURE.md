# 鳳凰之心 v17：權威性架構藍圖

這份文件是一份權威性的技術藍圖，旨在精準反映專案 v17 的最終形態。它不僅描繪了檔案結構和自動化流程，更深入闡述了其背後應對現代化開發挑戰的設計哲學與實踐經驗。

---

## 一、 核心設計哲學：從問題出發，持續演進

一個健壯的架構不是一次性設計出來的，而是圍繞著解決真實問題，不斷迭代演進的結果。我們的核心哲學是：**先求穩定，再求高效，最後追求智慧**。

### **遇到的三大核心困境 (The Three Bottlenecks)**
我們的架構是為了解決在現代 CI/CD 與自動化流程中普遍存在的三大瓶頸而設計的：
1.  **空間瓶頸 (硬碟空間耗盡)**: 在資源受限的容器化環境中，傳統「一次性安裝所有依賴」的流程極易導致硬碟空間不足而失敗。
2.  **時間瓶頸 (CPU 資源浪費)**: 單線程的循序測試無法充分利用多核心 CPU，導致測試時間過長，嚴重拖慢開發迭代速度。
3.  **穩定性瓶頸 (流程意外掛起)**: 單一測試案例的意外卡死（如 API 等待、死循環）會導致整個 CI/CD 流程被無限期阻塞，無法自動報告錯誤。

### **對應的三大核心策略 (The Three Solutions)**
-   **策略一：原子化隔離與即時清理 (解決空間瓶頸)**
    我們將每個測試任務視為一個「原子」單元。透過 `core_utils/safe_installer.py`，在安裝依賴前，系統會先檢查資源。測試前，僅為其建立一個包含最小依賴集的專用虛擬環境；測試結束後，立即徹底刪除該環境，將硬碟空間 100% 釋放。這確保了資源峰值佔用永遠在可控範圍內。

-   **策略二：輕量級多核心平行處理 (解決時間瓶頸)**
    我們透過 `smart_e2e_test.py` 中的 `multiprocessing` 實現應用級平行 (同時測試多個 App)，並利用 `pytest-xdist` 在每個 App 內部實現測試級平行。這套輕量級方案能在不增加空間負擔的前提下，壓榨 CPU 性能，大幅縮短測試總耗時。

-   **策略三：主動式超時強制中斷 (解決穩定性瓶頸)**
    我們為每一個測試案例都設定了一個「生命時鐘」（透過 `pytest-timeout`）。任何超時的測試都會被自動中斷並標記為失敗，確保 CI/CD 流程永遠不會被單一故障點所阻塞。

---

## 二、 v17 終極檔案結構與核心工具鏈

這是專案的最終檔案結構，精準反映了所有關鍵組件及其職責。

```
.
├── ALL_DATE/                 # 舊專案封存 (按使用者指示保留)
├── README.md                 # 您正在閱讀的檔案
├── WEB1/
│   └── config.json           # 由 Colab Runner 產生的設定檔
├── apps/                       # 所有獨立微服務的家
│   ├── dashboard_api/
│   ├── main_dashboard/
│   ├── quant/
│   └── transcriber/
├── config/                   # 全域設定中心
│   └── resource_settings.yml
├── core_utils/               # 核心工具模組
│   ├── __init__.py
│   ├── commander_console.py
│   ├── resource_monitor.py
│   └── safe_installer.py
├── docs/                       # 專案文件
│   ├── ARCHITECTURE.md
│   ├── Colab_Guide.md
│   ├── MISSION_DEBRIEFING.md
│   └── TEST.md
├── generate_report.py        # 【新】獨立的報告生成插件
├── launch.py                 # 主啟動腳本 (TUI 介面)
├── logs/                       # 日誌與報告的輸出目錄
├── phoenix_starter.py        # (可選) 視覺化啟動器
├── requirements-dev.in       # 開發環境的依賴聲明檔案
├── requirements-dev.txt      # 鎖定版本的開發依賴
├── run/                        # 特定環境的執行器
│   └── colab_runner.py
├── smart_e2e_test.py         # 智能測試腳本
├── temp/                       # 【新】暫存檔案、測試產物等的歸檔目錄
│   ├── proxy/
│   ├── test.db
│   ├── test.mp3
│   ├── test_phoenix_state.json
│   ├── transcriber_uploads/
│   └── uploads/
└── tests/                      # 品質保證中心
    ├── quant/
    ├── test_launch_installer.py
    └── transcriber/
```

### **核心工具鏈詳解:**
*   **`launch.py`**: 專案的**核心入口**。它負責啟動 TUI 介面、協調後端服務、監控資源，並在結束時觸發報告生成。它內建了依賴自動安裝和快速測試模式，是開發和執行的主要工具。
*   **`smart_e2e_test.py`**: 新一代的 Python **智能測試指揮官**。它取代了傳統的 shell 腳本，透過 `multiprocessing` 和 `pytest-xdist` 實現了前所未有的平行化測試能力，並整合 `pytest-timeout` 確保流程穩定性。
*   **`generate_report.py`**: 一個獨立的**報告生成「插件」**。它由 `launch.py` 在任務結束時透過 `subprocess` 呼叫，負責從 SQLite 資料庫中讀取數據並產生多維度的 Markdown 分析報告（包含趨勢圖和瓶頸分析），實現了報告與主邏輯的解耦。
*   **`run/colab_runner.py`**: 專為 Google Colab 設計的 **HTML 儀表板啟動器**。它透過讀寫分離的資料庫驅動架構，為使用者提供了一個視覺化的、即時更新的操作介面。
*   **`core_utils/`**: 專案的**「引擎室」**。包含了 `safe_installer.py` (原子化安全安裝)、`resource_monitor.py` (資源健康檢查) 和 `commander_console.py` (TUI 介面渲染) 等關鍵模組。
*   **`docs/`**: 包含本文件在內的**權威性技術文件**，是理解專案設計與演進的最佳起點。

---

## 三、 Colab 啟動器與 API 最終架構：資料庫驅動方案

### 核心概念：讀寫分離與單一真相來源
我們將**「做事」與「顯示」**完全分離。
1.  **寫入方 (`launch.py`)**: 作為後端主力部隊，`launch.py` 專心執行所有任務（安裝、啟動 App 等），並將所有狀態與日誌**持續寫入**唯一的真相來源：一個獨立的 **SQLite 資料庫 (`state.db`)**。
2.  **讀取方 (`run/colab_runner.py` 或其他 API 客戶端)**: 前端顯示器（例如 Colab Cell）或任何需要監控狀態的工具，則專心**讀取**數據。`launch.py` 在啟動時，會一併啟動一個輕量級的 **aiohttp API 伺服器**。這個 API 伺服器的唯一職責就是從 SQLite 資料庫讀取最新狀態，並以 JSON 格式提供給前端。

兩者透過資料庫和一個只讀的 API 進行溝通，互不干擾，確保了後端任務的穩定執行不會被前端的任何問題所影響。

### 架構草圖
```mermaid
graph TD
    subgraph "後端核心"
        D[🚀 launch.py<br>(背景主力部隊)] -- 寫入 --> C[(state.db)];
        E[🌐 aiohttp API<br>(由 launch.py 啟動)] -- 讀取 --> C;
    end

    subgraph "前端顯示"
        A[👨‍💻 使用者] --> B{Colab Cell};
        B -- 每秒 API 請求 --> E;
    end

    subgraph "離線分析"
        F[📄 generate_report.py] -- 讀取 --> C;
    end

    style C fill:#f9f,stroke:#333,stroke-width:2px
```

### 核心優勢
*   **極致穩定**：前端顯示的崩潰，完全不影響後端核心任務的執行。真相永遠保存在資料庫中。
*   **架構簡潔**：沒有任何額外的網路服務 (GoTTY, WebSocket)，只有 Python、aiohttp 和 SQLite，除錯和維護成本降至最低。
*   **數據完整與可重用**：所有事件和狀態都被完整記錄。任務結束後，獨立的 `generate_report.py` 可以隨時從資料庫中重新產生完整的執行報告，用於分析或歸檔。

---

## 四、架構演進歷程：從錯誤中學習

本節記錄了專案在發展過程中遇到的關鍵挑戰以及對應的解決方案，這些經驗是專案寶貴的無形資產。

### 1. 問題：CI/CD 環境下的儀表板不穩定
- **遇到的狀況**: 在早期的版本中，我們嘗試使用 `GoTTY` 或直接將 `launch.py` 的 TUI 輸出（包含大量 ANSI escape codes）串流到前端。這種方法非常脆弱，任何 TUI 渲染的微小錯誤、甚至是網路延遲，都會導致整個流程崩潰或卡死。
- **失敗的嘗試**: 繼續優化 TUI 輸出，試圖用更複雜的控制字元來解決問題。這讓程式碼變得愈加複雜且難以維護，治標不治本。
- **成功的解決方案 (v12)**: **引入資料庫驅動架構**。我們意識到問題的根源在於「執行」和「顯示」的耦合。透過讓 `launch.py` 只專注於將狀態寫入 SQLite，並讓前端只專注於從一個唯讀的 API 讀取數據，我們徹底切斷了兩者之間的直接聯繫，實現了極高的穩定性。

### 2. 問題：開發環境不一致與依賴地獄
- **遇到的狀況**: 開發者 A 在本地安裝了 `pandas v2.0`，測試通過；而開發者 B 安裝了 `pandas v2.1`，部分 API 行為發生變化導致測試失敗。這種「在我機器上可以跑」的問題嚴重影響了團隊協作效率。
- **失敗的嘗試**: 口頭約定大家使用相同的版本，或手動維護一個包含所有間接依賴的 `requirements.txt`。前者不可靠，後者極其繁瑣且容易出錯。
- **成功的解決方案 (v12+)**: **引入 `pip-tools` 進行依賴鎖定**。我們讓開發者只在 `requirements.in` 中聲明直接依賴，然後使用 `pip-compile` 命令自動生成包含所有層級依賴且版本被完全鎖定的 `requirements.txt`。這保證了任何環境下安裝的依賴都是完全一致的，根治了此問題。

### 3. 問題：報告系統與主邏輯耦合
- **遇到的狀況**: 最初，報告產生的邏輯是 `launch.py` 的一部分。這導致了幾個問題：
    1.  要測試報告功能，必須完整運行一次 `launch.py`，非常耗時。
    2.  報告邏輯的任何改動，都有可能意外影響到主程序的穩定性。
    3.  如果任務中途失敗，儲存下來的資料庫就無法被用來重新產生報告。
- **失敗的嘗試**: 在 `ReportGenerator` 類別中增加更多的錯誤處理，試圖隔離其影響。但這無法解決根本的耦合問題。
- **成功的解決方案 (v16)**: **報告系統插件化**。我們將報告邏輯完全移出，製作成一個獨立的 `generate_report.py` 命令列工具。`launch.py` 在結束時只負責呼叫這個腳本。這使得報告系統可以被獨立測試、獨立擴展，並且可以對任何符合格式的資料庫檔案執行，極大地增強了靈活性和可維護性。

### 4. 問題：核心依賴缺失導致執行失敗
- **遇到的狀況**: 在測試中發現，`generate_report.py` 在產生 Markdown 表格時，因缺少可選的 `tabulate` 套件而崩潰。
- **失敗的嘗試**: 僅在使用到該功能的地方加入 `try-except` 區塊。這雖然能防止崩潰，但會導致報告內容不完整，使用者體驗不佳。
- **成功的解決方案 (v17)**: **核心依賴前置檢查與自動安裝**。我們在 `launch.py` 和 `generate_report.py` 的入口處，加入了對所有核心依賴（包括 `pandas`, `tabulate`, `sparklines` 等）的檢查。如果發現缺少，腳本會嘗試自動安裝，若安裝失敗則會清晰地提示使用者如何手動安裝。這確保了腳本的開箱即用性，極大改善了使用者體驗。

---

## 五、V4 核心架構：預設快速驗證與參數化完整執行

V4 架構在 V3 的基礎上進行了關鍵的易用性改進，將**快速驗證模式設為預設行為**，同時保留了執行完整任務的能力。這使得開發者可以近乎即時地檢查 TUI 和核心日誌功能，極大地提升了日常開發和偵錯的效率。

### 核心變更：
*   **預設快速模式**：直接執行 `python launch.py` 將**不再**安裝任何大型依賴或啟動後端 App。它會立即啟動 TUI，模擬一個簡短的執行流程，並在幾秒鐘內完成。這成為了驗證系統核心顯示和日誌功能的標準方法。
*   **參數化完整模式**：過去的完整執行流程現在需要透過一個明確的命令列旗標來啟動：`python launch.py --full`。只有在指定此旗標時，系統才會執行完整的依賴安裝和後端服務啟動。
*   **內建依賴引導**：`launch.py` 現在能夠自我檢測並自動安裝其運行所需的核心 Python 套件（如 `pytz`, `psutil`, `ipython`, `nest_asyncio`），免除了使用者的手動設定步驟。

### 新的標準執行流程
1.  **日常開發與驗證 (預設)**:
    ```bash
    python launch.py
    ```
    *   **目的**：快速檢查 TUI 是否正常渲染，日誌是否可以生成。
    *   **耗時**：< 5 秒。

2.  **完整部署與測試 (手動觸發)**:
    ```bash
    python launch.py --full
    ```
    *   **目的**：執行完整的端到端流程，包括安裝所有應用的依賴、啟動後端服務。
    *   **耗時**：數分鐘（取決於網路速度和依賴大小）。

這個改進使得 `launch.py` 同時滿足了**快速迭代**和**完整執行**兩種核心需求，並透過將簡單性設為預設值，提供了更流暢的開發者體驗。
